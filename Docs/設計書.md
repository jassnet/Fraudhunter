# クリックログ集計・不正検知基盤 設計書（IP/UA重複調査）

## 1. 概要

### 1.1 背景

* 自社ASPでは ACS をトラッキング基盤として利用している。
* フラウド（不正トラフィック・不正成果）検知の一環として、
  「クリックログの IP / UserAgent（UA）重複パターン」から異常なトラフィックを検知したいニーズがある。
* しかし、clickログは 1 日あたり数十万件規模となるため、
  全件を都度生ログとして処理するアプローチは運用負荷や性能面のリスクがある。

### 1.2 目的

本設計書の目的は、以下の要件を満たすシステムの設計を明確にすること。

* ACS の clickログを定期取得し、自社DBに安全かつ効率的に蓄積する。
* IP × UA × 媒体 × 案件 × 日付ごとに集計した「クリック集計テーブル」を構築する。
* 集計テーブルを用いて、IP/UA 重複が多い組み合わせを抽出し、フラウド候補として運用部門に提示する。
* 将来的な拡張（成果ログとの連携、スコアリングロジックとの統合）を見据えた柔軟なデータモデルとする。

---

## 2. 対象範囲

本設計の対象は以下とする。

* ACS clickログ取得バッチ処理
* クリックログの格納・集計テーブル設計
* IP/UA重複検出ロジック（集計SQL・判定条件）
* 結果を参照するためのデータ提供（管理画面やBIツールから参照可能な状態）

対象外とするもの（別途設計）。

* 成果ログ（Action Log Raw）との結合によるスコアリング
* 媒体・案件への自動アラート/自動制御
* UI詳細設計（画面レイアウト・コンポーネント仕様）

---

## 3. 用語定義

* ACS：外部トラッキングシステム（本設計では一般的にACSと表現）
* clickログ：ACS が提供するクリック単位のログ（API: `/click_log/search` を想定）
* IP：`ipaddress` フィールド
* UA：`useragent` フィールド
* 媒体：`media_id`
* 案件：`program_id`（名称はACS仕様に合わせて変更）

---

## 4. 要件

### 4.1 機能要件

1. **クリックログ取得**

   * ACSのclickログAPIから指定期間（原則前日分）のクリックログを取得する。
   * ページングに対応し、1日分の全データを漏れなく取得する。
   * 取得範囲は日次バッチで「前日 00:00:00〜23:59:59」を基本とする。

2. **生ログ保存（オプション）**

   * 必要に応じて、取得したクリックログを `click_raw` テーブルに保存可能とする。
   * ストレージ制約により不要な場合は、集計処理のみ行い、生ログは保持しない構成も許容する。

3. **IP/UA × 媒体 × 案件 × 日次の集計**

   * クリックログを以下キーで集計する。

     * 日付（date）
     * 媒体ID（media_id）
     * 案件ID（program_id）
     * IPアドレス（ipaddress）
     * ユーザーエージェント（useragent）
   * 集計値として、以下を保持する。

     * `click_count`：当該キーでのクリック件数
     * `first_time`：当該キーで最初のクリック時刻
     * `last_time`：当該キーで最後のクリック時刻

4. **フラウド候補IP/UA抽出**

   * 日付単位で、条件を満たす「疑わしいIP/UA」を抽出する。
   * 条件の例：

     * 1IP/UAあたりのクリック数が異常に多い（例：50件以上）
     * 同一IP/UAが複数媒体・複数案件に跨って出現している など
   * 抽出結果を管理画面・BIツールから参照できるテーブルとして提供する。

5. **リラン対応**

   * 任意の日付について再取得・再集計が可能であること。
   * データ不備や閾値変更に対し、翌日以降の再集計が容易であること。

### 4.2 非機能要件

* **性能**

  * 1日あたりクリック数：最大 1,000,000 件程度まで対応可能とする。
  * バッチ処理時間：1日分のデータ処理が1時間以内に完了することを目標とする。
* **拡張性**

  * 将来的に成果ログ、媒体KPI等とのJOINを行う想定で、キー設計と正規化を意識する。
* **可用性**

  * API障害やネットワークエラーに備え、リトライや手動リランで復旧可能とする。

---

## 5. 全体アーキテクチャ

### 5.1 構成要素

1. **ACS**

   * `/click_log/search` APIを提供する外部サービス。

2. **バッチサーバ**

   * ACS API呼び出しロジックを実装する。
   * 日次ジョブスケジューラ（cron等）で定期実行。

3. **アプリケーションDB**

   * `click_raw` テーブル（任意）
   * `click_ipua_daily` テーブル（集計）
   * `click_ipua_suspicious` ビューまたはテーブル（疑わしいIP/UAの抽出結果）

4. **管理画面 / BIツール**

   * `click_ipua_daily` および `click_ipua_suspicious` を参照する。

### 5.2 データフロー

1. 日次バッチ起動（例：毎日 03:00）。
2. 対象日付（前日）のclickログをACSからページング取得。
3. 取得データを逐次集計し、`click_ipua_daily`にUPSERT。

   * オプションで `click_raw` にもINSERT。
4. 集計完了後、IP/UA重複判定ロジックで `click_ipua_suspicious` を更新、またはビューを参照。
5. 管理画面 / BIツールから前日分の疑わしいIP/UAを確認。

---

## 6. テーブル設計

### 6.1 click_raw テーブル（任意）

生ログを保持する場合のテーブル。保持しない方針ならこのテーブルは省略可能。

```text
テーブル名: click_raw

カラム:
- id             BIGINT / VARCHAR     PK（ACS側のクリックID等）
- click_time     TIMESTAMP            クリック日時
- media_id       VARCHAR              媒体ID
- program_id     VARCHAR              案件ID
- ipaddress      VARCHAR(45)          IPアドレス (IPv4/IPv6想定)
- useragent      TEXT                 ユーザーエージェント
- referrer       TEXT                 リファラURL
- raw_payload    JSON                 ACSから取得した元レスポンス（任意）
- created_at     TIMESTAMP            レコード作成日時
- updated_at     TIMESTAMP            レコード更新日時

インデックス:
- IDX_click_raw_time      (click_time)
- IDX_click_raw_media     (media_id, click_time)
- IDX_click_raw_program   (program_id, click_time)
```

### 6.2 click_ipua_daily テーブル（集計）

IP/UA単位の集計テーブル。

```text
テーブル名: click_ipua_daily

カラム:
- date          DATE                 日付 (集計単位)
- media_id      VARCHAR              媒体ID
- program_id    VARCHAR              案件ID
- ipaddress     VARCHAR(45)          IPアドレス
- useragent     TEXT                 ユーザーエージェント
- click_count   INT                  当日クリック数
- first_time    TIMESTAMP            当日最初のクリック時刻
- last_time     TIMESTAMP            当日最後のクリック時刻
- created_at    TIMESTAMP            レコード作成日時
- updated_at    TIMESTAMP            レコード更新日時

主キー:
- PRIMARY KEY (date, media_id, program_id, ipaddress, useragent)

インデックス（必要に応じて）:
- IDX_click_ipua_daily_date              (date)
- IDX_click_ipua_daily_date_ip          (date, ipaddress)
- IDX_click_ipua_daily_date_ipua        (date, ipaddress, useragent)
- IDX_click_ipua_daily_date_media       (date, media_id)
- IDX_click_ipua_daily_date_program     (date, program_id)
```

### 6.3 click_ipua_suspicious ビュー / テーブル

疑わしいIP/UAを抽出するためのビューまたはマテリアライズドビュー。

#### 案1：ビュー定義例（簡易）

```sql
CREATE VIEW click_ipua_suspicious AS
SELECT
  date,
  ipaddress,
  useragent,
  SUM(click_count) AS total_clicks,
  COUNT(DISTINCT media_id)   AS media_count,
  COUNT(DISTINCT program_id) AS program_count,
  MIN(first_time) AS first_time,
  MAX(last_time)  AS last_time
FROM click_ipua_daily
GROUP BY date, ipaddress, useragent
HAVING
  SUM(click_count) >= 50      -- 閾値1: トータルクリック数
  OR COUNT(DISTINCT media_id) >= 3   -- 閾値2: 媒体数
  OR COUNT(DISTINCT program_id) >= 3; -- 閾値3: 案件数
```

#### 案2：日次マテリアライズドテーブル

* 前日分だけを `click_ipua_suspicious_daily` テーブルにINSERTする方式も候補。
* 大量データの場合、ビューのオンデマンド集計が重くなるためマテリアライズドにする判断もあり。

---

## 7. バッチ処理設計

### 7.1 ジョブ構成

1. `JOB_CLICK_LOG_IMPORT`

   * ACSからclickログを取得し、`click_ipua_daily` を更新するジョブ。

2. （任意）`JOB_CLICK_IPUA_SUSPICIOUS`

   * `click_ipua_daily` から `click_ipua_suspicious_daily` を作るジョブ
     ※ビュー方式なら不要。

### 7.2 実行スケジュール

* 毎日 03:00 に、前日（00:00〜23:59）のデータについて1回実行。
* 手動リラン用に任意の日付をパラメータ指定して実行できるようにする。

### 7.3 ACS API呼び出し仕様（例）

* エンドポイント：`GET /click_log/search`
* 認証：

  * `X-Auth-Token: {accessKey}:{secretKey}`
* 主なパラメータ例：

  * `date_y`: 年
  * `date_m`: 月
  * `date_d`: 日
  * `limit`: 取得件数（例：1000）
  * `page`: ページ番号

疑似フロー：

```pseudo
target_date = 前日 or 指定日

page = 1
while True:
    res = GET /click_log/search?date_y=...&date_m=...&date_d=...&limit=1000&page=page
    if res.records is empty:
        break

    for each record in res.records:
        -- 集計ロジックへ（下記参照）

    page += 1
```

### 7.4 集計ロジック詳細（UPSERT）

1レコードごとに以下を実行。

```pseudo
d = date(click.click_time)
key = (d, click.media_id, click.program_id, click.ipaddress, click.useragent)

-- 任意: click_raw への INSERT（必要な場合のみ）

-- click_ipua_daily への UPSERT
if key が存在:
    click_ipua_daily[key].click_count += 1
    click_ipua_daily[key].last_time = max(last_time, click.click_time)
    updated_at = NOW()
else:
    INSERT click_ipua_daily (
        date, media_id, program_id, ipaddress, useragent,
        click_count, first_time, last_time,
        created_at, updated_at
    ) VALUES (
        d, click.media_id, click.program_id, click.ipaddress, click.useragent,
        1, click.click_time, click.click_time,
        NOW(), NOW()
    )
```

RDBMSごとの実装例（PostgreSQL想定）：

```sql
INSERT INTO click_ipua_daily (
  date, media_id, program_id, ipaddress, useragent,
  click_count, first_time, last_time, created_at, updated_at
)
VALUES (
  :date, :media_id, :program_id, :ipaddress, :useragent,
  1, :click_time, :click_time, NOW(), NOW()
)
ON CONFLICT (date, media_id, program_id, ipaddress, useragent)
DO UPDATE SET
  click_count = click_ipua_daily.click_count + 1,
  last_time   = GREATEST(click_ipua_daily.last_time, EXCLUDED.last_time),
  updated_at  = NOW();
```

### 7.5 エラーハンドリング・リトライ

* ACS API呼び出しが失敗した場合：

  * HTTPステータスが5xx：指数バックオフ付きでリトライ（例：最大3回）。
  * 4xxエラー：ログを出力し、そのページ分はスキップして運用アラートを上げる。
* DBエラー：

  * トランザクション単位でロールバックし、バッチ全体をエラー終了。
  * 対象日のリランで再実行可能とする。

---

## 8. IP/UA重複調査ロジック

### 8.1 基本的な抽出SQL例

#### 8.1.1 日付単位での多クリックIP/UAランキング

```sql
SELECT
  date,
  ipaddress,
  useragent,
  SUM(click_count) AS total_clicks,
  COUNT(*)         AS ipua_rows,
  COUNT(DISTINCT media_id)   AS media_count,
  COUNT(DISTINCT program_id) AS program_count,
  MIN(first_time) AS first_time,
  MAX(last_time)  AS last_time
FROM click_ipua_daily
WHERE date = :target_date
GROUP BY date, ipaddress, useragent
HAVING
  SUM(click_count) >= :click_threshold      -- 例: 50
ORDER BY total_clicks DESC
LIMIT 100;
```

#### 8.1.2 案件別での怪しいIP/UA

```sql
SELECT
  date,
  program_id,
  ipaddress,
  useragent,
  click_count,
  first_time,
  last_time
FROM click_ipua_daily
WHERE date       = :target_date
  AND program_id = :program_id
  AND click_count >= :program_click_threshold -- 例: 20
ORDER BY click_count DESC;
```

### 8.2 判定ルール例（初期案）

初期運用として、シンプルな条件を想定。

例）

1. **全案件合算で怪しいIP/UA**

   * `SUM(click_count) >= 50`
2. **複数媒体・複数案件に跨るIP/UA**

   * `media_count >= 3` もしくは `program_count >= 3`
3. **時間的に集中しているIP/UA**

   * `last_time - first_time <= 10分` かつ `total_clicks >= 20`

これらを組み合わせて `click_ipua_suspicious` の抽出条件とする。
